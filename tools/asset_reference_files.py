import argparse
from pathlib import Path

from retro_data_structures.asset_reference import AssetReference
from retro_data_structures.file_tree_editor import IsoFileProvider, FileTreeEditor
from retro_data_structures.formats import Strg, Mlvl
from retro_data_structures.game_check import Game
from retro_data_structures.references import reference_database

_CUSTOM_WORLD_NAMES = {
    Game.ECHOES: {
        0x69802220: "FrontEnd",
        0xA50A80CC: "M01_SidehopperStation",
        0xAE171602: "M02_Spires",
        0xE3B0C703: "M03_CrossfireChaos",
        0x233E42BE: "M04_Pipeline",
        0x406ADD7F: "M05_SpiderComplex",
        0x7E19ED26: "M06_ShootingGallery",
    }
}


def filter_name(s: str) -> str:
    result = s.replace("!", "").replace(" ", "_").replace("'", "").replace('"', "").upper()
    while result and not result[0].isalpha():
        result = result[1:]
    return result


def generate_template(items: dict[str, int]) -> str:
    p = Path(__file__)
    generator = p.relative_to(p.parents[1]).as_posix()
    template = f"# Generated by {generator}\n\n"
    template += 'from retro_data_structures.references.reference_database import echoes_db as _echoes_db\n\n'
    template += '_db = _echoes_db()\n\n'
    template += "\n".join(
        f"{key} = _db[{hex(items[key])}]"
        for key in sorted(items)
    )
    template += "\n"
    return template


def create_asset_reference_files(editor: FileTreeEditor, output_path: Path):
    custom_world_names = _CUSTOM_WORLD_NAMES.get(editor.target_game, {})
    world_names = {}

    print("> Creating prime2_reference.bin")
    reference_database._ConstructReferenceDB.build_file(
        [{
            "asset_id": asset_id,
            "name": f"prime2/game_0x{asset_id:08x}.{editor.get_asset_type(AssetReference(asset_id, '', False))}"
        } for asset_id in editor.all_asset_ids()],
        output_path.joinpath("prime2_reference.bin")
    )
    echoes_db = reference_database.echoes_db()

    output_path = output_path.joinpath("echoes")
    output_path.mkdir(exist_ok=True)

    print("> Processing all MLVL")
    for value in editor.all_asset_ids():
        reference = echoes_db[value]
        if editor.get_asset_type(reference).lower() != "mlvl":
            continue

        mlvl = editor.get_parsed_asset(reference, type_hint=Mlvl)

        try:
            strg = editor.get_parsed_asset(echoes_db[mlvl.world_name_id], type_hint=Strg)
            world_name = strg.raw.string_tables[0].strings[0].string
        except KeyError:
            if value not in custom_world_names:
                print(f"Skipping MLVL {value}: no name found")
                continue
            world_name = custom_world_names[value]

        print(f">> Processing {world_name}")
        world_name = filter_name(world_name)
        world_names[f"{world_name}_MLVL"] = value

        names = {}

        for area in mlvl.raw.areas:
            try:
                strg = editor.get_parsed_asset(echoes_db[area.area_name_id], type_hint=Strg)
                area_name = strg.raw.string_tables[0].strings[0].string
            except KeyError:
                area_name = area.internal_area_name

            names[f"{filter_name(area_name)}_MREA"] = area.area_mrea_id

        output_path.joinpath(f"{world_name.lower()}.py").write_text(generate_template(names))

    output_path.joinpath("world.py").write_text(generate_template(world_names))


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--game", required=True, choices=["echoes"])
    parser.add_argument("--iso", required=True, type=Path,
                        help="Path to where the ISO.")
    args = parser.parse_args()

    create_asset_reference_files(
        FileTreeEditor(IsoFileProvider(args.iso), Game.ECHOES),
        Path(__file__).parents[1].joinpath("retro_data_structures", "references"),
    )


if __name__ == '__main__':
    main()
